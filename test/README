Files in this folder implement test generation.
The test are run by issuing the following commands from the cci-haskell parent folder:

cabal config -f "examples" --enable-tests
cabal build
cabal test

There are worker processes which test the CCI features, and there is a driver process
which tell the workers what they must do. The driver communicates with the workers
through the standard input and output.

Workers store the standard error output in files worker-stderr<N>.txt, where
N identifies the process internally to the test generator. Subsequent test
runs overwrite this files though. They are useful to debug the run of a single
command sequence with TestGen.runCommands.

A test is written as in test/Props.hs:

1. main = do
2.    errs <- testProp defaultTestConfig "example prop" (\_cmds _rs -> True)
3.    mapM_ print errs
4.    when (not (null errs)) exitFailure

Line (2) generates multiple tests and test a predicate over them. That is,
it generates the commands for the workers, collects the worker responses and then 
evaluates a predicate feeding it with the commands and the responses. If the 
property holds, the test passes otherwise the provided commands and responses are
collected in the result of @testProp@. The previous procedure is repeated as many 
times as specified in the @defaultTestConfig@ parameter:

-- | Parameters for running tests
data TestConfig = TestConfig 
    { nProcesses :: Int -- ^ Number of processes in tests
    , nSends     :: Int -- ^ Number of sends in each interaction
    , nTries     :: Int -- ^ Number of tests to run 
    , nErrors    :: Int -- ^ Number of errors to collect before stopping
    }

defaultTestConfig :: TestConfig
defaultTestConfig = TestConfig
    { nProcesses = 2
    , nSends     = 1
    , nTries     = 5
    , nErrors    = 2
    }

The exitFailure in line (4) causes the program to terminate with a non-zero
code. This tells the cabal framework that the test failed.

During execution of @testProp@, when a command sequence is found that causes
the predicate to yield false, the command sequence is pruned of superfluous
commands before presenting collecting it as part of the result. A command
is considered superfluous if removing it still causes the predicate to yield
False.

The function @runCommands@ from module TestGen can be used to rerun commands
that produced a bug.

The driver process first spawns all the worker processes and then sends 
commands to each worker once at a time in some random (but reproducible)
order. The workers respond back with an Idle response when they have finished
processing a command so the driver can deliver some other command to some
potentially different worker. This strong synchronization between workers
and driver should help making the bugs reproducible.

Definitions of commands and responses can be found in test/Commands.hs.


Once you find a failing command sequence like:

test :: [(Int,Command)]
test = read "[([0],Accept 0),([1],Accept 1),([1],ConnectTo \"\" 0 0 Nothing),([1,0],WaitConnection 0),([1],Send 0 2 \"2\"),([1],WaitSendCompletion 0 2),([0],WaitRecv 0 2),([1],Send 0 1 \"1\"),([0],ConnectTo \"\" 1 1 Nothing),([0,1],WaitConnection 1),([0],Send 1 2 \"2\"),([1],WaitSendCompletion 0 1),([0],WaitSendCompletion 1 2),([1],WaitRecv 1 2),([0],WaitRecv 0 1),([0],Send 1 1 \"1\"),([0],WaitSendCompletion 1 1),([1],WaitRecv 1 1),([0],Disconnect 1),([1],Disconnect 0)]"

, it can be rerun with

main :: IO ()
main = runCommands test >>= print

or with

main :: IO ()
main = testCommands "example prop" test 2 (\_cmds _rs -> your prop) >>= print
  
A C test program can be generated that executes the command sequence using the CCI C API:

main :: IO ()
main = writeFile "t.c"$ generateCTest test

The C program will be saved to t.c. It needs to be compiled and linked with 
test/testlib.c. Assuming it is compiled into an executable called "t", it 
can be run with:

CCI_CONFIG=cci.ini ./t


